#!/bin/bash

# Color constants
RED='\033[0;31m'
GRN='\033[0;32m'
YLW='\033[0;33m'
BLU='\033[0;34m'
MAG='\033[0;35m'
CYA='\033[0;36m'
DGR='\033[1;30m'
BLD='\033[1m'
X='\033[0m' # No Color

# Print help screen
show_help() {
  echo -e "${BLD}${CYA}Reactotron TurboModule Generator${X}"
  echo ""
  echo -e "${BLD}Usage:${X}"
  echo "  ./bin/turbomodule <command> [module_name]"
  echo ""
  echo -e "${BLD}Commands:${X}"
  echo -e "  ${GRN}add${X}      Create a new TurboModule"
  echo -e "  ${RED}remove${X}   Remove an existing TurboModule (alias: rm)"
  echo -e "  ${MAG}apply${X}    Build TurboModules from comments in package.json turbomodules"
  echo -e "  ${BLU}help${X}     Show this help screen"
  echo ""
  echo -e "${BLD}Examples:${X}"
  echo "  ./bin/turbomodule add IRMyNewThing"
  echo "  ./bin/turbomodule remove IRMyNewThing"
  echo "  ./bin/turbomodule apply"
  echo ""
  echo -e "${BLD}What it does:${X}"
  echo "  • Creates .mm files in ./app/native/"
  echo "  • Creates TypeScript spec in ./app/native/"
  echo "  • Auto-links files into Xcode project on pod install"
  echo "  • Includes sync method, async method, and events"
  echo "  • apply: Generates native files from @turbomodule comments"
  echo ""
}

# Print colored output
print_success() { echo -e "${GRN}✓${X} $1"; }
print_error() { echo -e "${RED}✗${X} $1"; }
print_warning() { echo -e "${YLW}⚠${X} $1"; }
print_info() { echo -e "${BLU}ℹ${X} $1"; }
print_step() { echo -e "${MAG}→${X} $1"; }

# Check if git tree is clean
check_git_status() {
  if ! git diff-index --quiet HEAD --; then
    print_warning "Git tree is not clean. You have uncommitted changes."
    echo ""
    echo -e "${YLW}Current changes:${X}"
    git status --porcelain
    echo ""
    read -p "Do you want to continue? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      print_error "Aborted."
      exit 1
    fi
  fi
}

# Create git checkpoint
create_checkpoint() {
  local checkpoint_name="turbomodule-checkpoint-$(date +%s)"
  git stash push -m "$checkpoint_name" --include-untracked
  echo "$checkpoint_name"
}

# Restore from checkpoint
restore_checkpoint() {
  local checkpoint_name="$1"
  local stash_id=$(git stash list | grep "$checkpoint_name" | head -1 | cut -d: -f1)
  if [[ -n "$stash_id" ]]; then
    git stash pop "$stash_id"
    print_success "Restored from checkpoint"
  else
    print_warning "Could not find checkpoint to restore"
  fi
}

# Validate module name
validate_module_name() {
  local name="$1"
  if [[ -z "$name" ]]; then
    print_error "Module name is required"
    exit 1
  fi
  
  if [[ ! "$name" =~ ^[A-Z][A-Za-z0-9]*$ ]]; then
    print_error "Module name must start with uppercase letter and contain only letters/numbers"
    exit 1
  fi
}

# Generate file from template
generate_from_template() {
  local template_content="ERROR"
  local module_name="$1"
  local template_path="$2"
  local output_path="$3"
  local template_name="$4"
  
  template_content=$(cat "$template_path")
  local replaced_content=${template_content//$template_name/$module_name}
  echo "$replaced_content" > "$output_path"
  print_success "Created $output_path"
}

# Link files using pod install
link_files() {
  print_step "Installing pods and linking files to Xcode project..."
  npm run pod
}

# Add new TurboModule
add_module() {
  local checkpoint=""
  local module_name="$1"
  
  print_info "Creating TurboModule: $module_name"
  
  # Check git status
  check_git_status
  
  # Create checkpoint
  print_step "Creating git checkpoint..."
  checkpoint=$(create_checkpoint)
  
  # Validate module name
  validate_module_name "$module_name"

  # Check if the folder already exists
  if [[ -d "app/native/${module_name}" ]]; then
    print_error "Module $module_name already exists"
    restore_checkpoint "$checkpoint"
    exit 1
  fi
  
  # Check if files already exist
  if [[ -f "app/native/${module_name}/${module_name}.mm" ]] || [[ -f "app/native/${module_name}/Native${module_name}.ts" ]]; then
    print_error "Module $module_name already exists"
    restore_checkpoint "$checkpoint"
    exit 1
  fi
  
  # Generate files
  print_step "Generating files..."
  generate_from_template "$module_name" "./bin/templates/MyTemplate.mm" "app/native/${module_name}/${module_name}.mm" "MyTemplate"
  generate_from_template "$module_name" "./bin/templates/NativeMyTemplate.ts" "app/native/${module_name}/Native${module_name}.ts" "MyTemplate"
  
  # Link files
  link_files
  
  print_success "TurboModule $module_name created successfully!"
  print_info "Files created:"
  echo "  • app/native/${module_name}/${module_name}.mm"
  echo "  • app/native/${module_name}/Native${module_name}.ts"
  echo ""
  echo "  Now go edit the .mm file and add your methods."
  echo "  If you need help, read ./docs/Making-a-TurboModule.md"
  echo ""
}

# Remove TurboModule
remove_module() {
  local checkpoint=""
  local module_name="$1"
  
  print_info "Removing TurboModule: $module_name"
  
  # Check git status
  check_git_status
  
  # Create checkpoint
  print_step "Creating git checkpoint..."
  checkpoint=$(create_checkpoint)
  
  # Validate module name
  validate_module_name "$module_name"

  # Remove folder
  rm -rf "app/native/${module_name}"
  print_success "Removed TurboModule: app/native/${module_name}"
  
  # Link files to update Xcode project
  link_files
  
  print_success "TurboModule $module_name removed successfully!"
}

# Parse turbomodule comment and extract module info
parse_turbomodule_comment() {
  local file_path="$1"
  local content=$(cat "$file_path")
  
  # Extract the @turbomodule line
  local turbomodule_line=$(echo "$content" | grep -E "^/\* @turbomodule" | head -1)
  
  if [[ -z "$turbomodule_line" ]]; then
    return 1
  fi
  
  # Parse: @turbomodule ModuleName.methodName(): returnType
  local pattern="^/\* @turbomodule ([A-Za-z0-9]+)\.([A-Za-z0-9]+)\(\): ([A-Za-z0-9]+)"
  if [[ "$turbomodule_line" =~ $pattern ]]; then
    echo "${BASH_REMATCH[1]}:${BASH_REMATCH[2]}:${BASH_REMATCH[3]}"
  else
    return 1
  fi
}

# Extract native code from comment block
extract_native_code() {
  local file_path="$1"
  local content=$(cat "$file_path")
  
  # Extract everything between /* and */ excluding the @turbomodule line
  local native_code=$(echo "$content" | sed -n '/^\/\* @turbomodule/,/^\*\//p' | sed '1d;$d')
  echo "$native_code"
}

# Generate native files from turbomodule comment
generate_native_files() {
  local file_path="$1"
  local module_info="$2"
  
  # Parse module info
  IFS=':' read -r module_name method_name return_type <<< "$module_info"
  
  # Get directory of the TypeScript file
  local dir_path=$(dirname "$file_path")
  local file_name=$(basename "$file_path" .ts)
  
  # Extract native code
  local native_code=$(extract_native_code "$file_path")
  
  # Generate .mm file using template
  local mm_file="$dir_path/${module_name}.mm"
  local mm_template_content=$(cat << 'EOT'
#import "MODULE_NAME.h"
// HEADERS_HERE

@implementation MODULE_NAME RCT_EXPORT_MODULE()

// METHODS_HERE

- (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:(const facebook::react::ObjCTurboModule::InitParams &)params {
  return std::make_shared<facebook::react::NativeMyTemplateSpecJSI>(params);
}
@end
EOT
)

  local mm_content=${mm_template_content//MODULE_NAME/$module_name}

  # Replace the headers section with any lines that start with #import
  local headers=$(echo "$native_code" | grep -E "^#import")
  if [[ -n "$headers" ]]; then
    mm_content=${mm_content//\// HEADERS_HERE/$headers}
  else
    mm_content=${mm_content//\// HEADERS_HERE/}
  fi

  # Replace the method section with our extracted native code, minus the headers
  local method_start=$(echo "$mm_content" | grep -n "// METHODS_HERE" | cut -d: -f1)
  local method_end=$(echo "$mm_content" | grep -n "// METHODS_HERE" | cut -d: -f1)
  
  # Filter out any lines that start with #import
  local filtered_native_code=$(echo "$native_code" | grep -v "^#import")
  
  if [[ -n "$method_start" && -n "$method_end" ]]; then
    local before_methods=$(echo "$mm_content" | head -n $((method_start)))
    local after_methods=$(echo "$mm_content" | tail -n +$((method_end)))
    echo "$before_methods" > "$mm_file"
    echo "$filtered_native_code" >> "$mm_file"
    echo "$after_methods" >> "$mm_file"
  else
    # Fallback if template structure changes
    echo "$mm_content" > "$mm_file"
  fi
  
  print_success "Generated $mm_file"
  
  # Generate Native TypeScript file using template
  local native_ts_file="$dir_path/Native${module_name}.ts"
  local ts_template_content=$(cat << 'EOT'
import type { TurboModule } from "react-native"
import { TurboModuleRegistry } from "react-native"
export interface Spec extends TurboModule {
  // METHODS_HERE
}
export default TurboModuleRegistry.getEnforcing<Spec>("MODULE_NAME")
EOT
)

  local ts_content=${ts_template_content//MyTemplate/$module_name}
  
  # Replace the method signature with our specific method
  ts_content=$(echo "$ts_content" | sed "s/getADictionary/${method_name}/g")
  ts_content=$(echo "$ts_content" | sed "s/getADictionaryAsync/${method_name}Async/g")
  ts_content=$(echo "$ts_content" | sed "s/someString: string,//g")
  ts_content=$(echo "$ts_content" | sed "s/Promise<{ someString: string; someNumber: number; someBool: boolean }>/Promise<${return_type}>/g")
  
  echo "$ts_content" > "$native_ts_file"
  print_success "Generated $native_ts_file"
}

# Apply turbomodules from package.json
apply_turbomodules() {
  print_info "Applying turbomodules from package.json"
  
  # Check git status
  check_git_status
  
  # Create checkpoint
  print_step "Creating git checkpoint..."
  local checkpoint=$(create_checkpoint)
  
  # Read turbomodules from package.json
  local turbomodules=()
  while IFS= read -r line; do
    if [[ "$line" =~ ^[[:space:]]*\"([^\"]+)\" ]]; then
      turbomodules+=("${BASH_REMATCH[1]}")
    fi
  done < <(grep -A 10 '"turbomodules"' package.json | grep -E '"[^"]+"' | sed 's/.*"\([^"]*\)".*/\1/')
  
  if [[ ${#turbomodules[@]} -eq 0 ]]; then
    print_warning "No turbomodules found in package.json"
    return
  fi
  
  print_step "Found ${#turbomodules[@]} turbomodule(s) to process"
  
  local processed=0
  local errors=0
  
  for file_path in "${turbomodules[@]}"; do
    if [[ ! -f "$file_path" ]]; then
      print_error "File not found: $file_path"
      ((errors++))
      continue
    fi
    
    print_step "Processing $file_path"
    
    # Parse turbomodule comment
    local module_info=$(parse_turbomodule_comment "$file_path")
    if [[ $? -ne 0 ]]; then
      print_error "Invalid @turbomodule comment in $file_path"
      ((errors++))
      continue
    fi
    
    # Generate native files
    generate_native_files "$file_path" "$module_info"
    ((processed++))
  done
  
  if [[ $errors -gt 0 ]]; then
    print_warning "Completed with $errors error(s)"
  else
    print_success "Successfully processed $processed turbomodule(s)"
  fi
  
  # Link files
  link_files
}

# Main script logic
main() {
  local command="$1"
  local module_name="$2"
  
  case "$command" in
    "help"|"--help"|"-h")
      show_help
      ;;
    "add")
      if [[ -z "$module_name" ]]; then
        print_error "Module name is required for 'add' command"
        echo "Usage: ./bin/turbomodule add <module_name>"
        exit 1
      fi
      add_module "$module_name"
      ;;
    "remove"|"rm")
      if [[ -z "$module_name" ]]; then
        print_error "Module name is required for 'remove' command"
        echo "Usage: ./bin/turbomodule remove <module_name>"
        exit 1
      fi
      remove_module "$module_name"
      ;;
    "apply")
      apply_turbomodules
      ;;
    "")
      show_help
      ;;
    *)
      print_error "Unknown command: $command"
      echo ""
      show_help
      exit 1
      ;;
  esac
}

# Run main function with all arguments
main "$@"

